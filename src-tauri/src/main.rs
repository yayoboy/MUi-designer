// Prevents additional console window on Windows in release
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use serde::{Deserialize, Serialize};
use std::fs;

// ============================================================================
// Data Structures
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Project {
    pub name: String,
    pub version: String,
    pub display: DisplayConfig,
    pub components: Vec<Component>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisplayConfig {
    pub width: u32,
    pub height: u32,
    pub driver: String,
    pub protocol: Protocol,
    pub pinout: Pinout,
    pub rotation: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Protocol {
    SPI,
    I2C,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Pinout {
    pub cs: Option<u8>,
    pub dc: Option<u8>,
    pub rst: Option<u8>,
    pub mosi: Option<u8>,
    pub sck: Option<u8>,
    pub sda: Option<u8>,
    pub scl: Option<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Component {
    pub id: String,
    pub component_type: ComponentType,
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub properties: ComponentProperties,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ComponentType {
    Button,
    Label,
    Image,
    Rectangle,
    Circle,
    Line,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComponentProperties {
    pub text: Option<String>,
    pub font_size: Option<u32>,
    pub color: Option<String>,
    pub background_color: Option<String>,
    pub border_color: Option<String>,
    pub border_width: Option<u32>,
    pub image_path: Option<String>,
    pub alignment: Option<String>,
}

// ============================================================================
// Tauri Commands
// ============================================================================

#[tauri::command]
fn save_project(path: String, project: Project) -> Result<String, String> {
    let json = serde_json::to_string_pretty(&project)
        .map_err(|e| format!("Failed to serialize project: {}", e))?;

    fs::write(&path, json)
        .map_err(|e| format!("Failed to write file: {}", e))?;

    Ok(format!("Project saved successfully to {}", path))
}

#[tauri::command]
fn load_project(path: String) -> Result<Project, String> {
    let content = fs::read_to_string(&path)
        .map_err(|e| format!("Failed to read file: {}", e))?;

    let project: Project = serde_json::from_str(&content)
        .map_err(|e| format!("Failed to parse project: {}", e))?;

    Ok(project)
}

#[tauri::command]
fn generate_arduino_code(project: Project) -> Result<String, String> {
    // TODO: Implement Arduino code generation with templates
    let code = format!(
        r#"// Generated by MUi Designer
// Project: {}

#include <Adafruit_GFX.h>
#include <Adafruit_{}.h>

// Display configuration
#define SCREEN_WIDTH {}
#define SCREEN_HEIGHT {}

// Pin definitions
{}

Adafruit_{} display({});

void setup() {{
  Serial.begin(115200);

  // Initialize display
  {}

  // Draw UI components
  drawUI();
}}

void loop() {{
  // Your code here
}}

void drawUI() {{
{}
}}
"#,
        project.name,
        project.display.driver,
        project.display.width,
        project.display.height,
        generate_pin_definitions(&project.display),
        project.display.driver,
        generate_display_constructor(&project.display),
        generate_display_init(&project.display),
        generate_component_code(&project.components)
    );

    Ok(code)
}

#[tauri::command]
fn generate_esphome_code(project: Project) -> Result<String, String> {
    // TODO: Implement ESPHome YAML generation with templates
    let yaml = format!(
        r#"# Generated by MUi Designer
# Project: {}

esphome:
  name: {}
  platform: ESP32
  board: esp32dev

wifi:
  ssid: "YOUR_SSID"
  password: "YOUR_PASSWORD"

logger:

api:

ota:

display:
  - platform: {}
    id: my_display
    cs_pin: {}
    dc_pin: {}
    reset_pin: {}
    lambda: |-
{}
"#,
        project.name,
        project.name.to_lowercase().replace(" ", "_"),
        project.display.driver.to_lowercase(),
        project.display.pinout.cs.unwrap_or(5),
        project.display.pinout.dc.unwrap_or(4),
        project.display.pinout.rst.unwrap_or(16),
        generate_esphome_lambda(&project.components)
    );

    Ok(yaml)
}

// ============================================================================
// Helper Functions
// ============================================================================

fn generate_pin_definitions(display: &DisplayConfig) -> String {
    let mut pins = Vec::new();

    match display.protocol {
        Protocol::SPI => {
            if let Some(cs) = display.pinout.cs {
                pins.push(format!("#define TFT_CS {}", cs));
            }
            if let Some(dc) = display.pinout.dc {
                pins.push(format!("#define TFT_DC {}", dc));
            }
            if let Some(rst) = display.pinout.rst {
                pins.push(format!("#define TFT_RST {}", rst));
            }
        }
        Protocol::I2C => {
            if let Some(sda) = display.pinout.sda {
                pins.push(format!("#define I2C_SDA {}", sda));
            }
            if let Some(scl) = display.pinout.scl {
                pins.push(format!("#define I2C_SCL {}", scl));
            }
        }
    }

    pins.join("\n")
}

fn generate_display_constructor(display: &DisplayConfig) -> String {
    match display.protocol {
        Protocol::SPI => "TFT_CS, TFT_DC, TFT_RST".to_string(),
        Protocol::I2C => "SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1".to_string(),
    }
}

fn generate_display_init(display: &DisplayConfig) -> String {
    match display.protocol {
        Protocol::SPI => {
            "if(!display.begin()) {\n    Serial.println(\"Display initialization failed!\");\n    while(1);\n  }\n  display.setRotation(0);\n  display.fillScreen(0x0000);".to_string()
        }
        Protocol::I2C => {
            "Wire.begin(I2C_SDA, I2C_SCL);\n  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"Display initialization failed!\");\n    while(1);\n  }\n  display.clearDisplay();\n  display.display();".to_string()
        }
    }
}

fn generate_component_code(components: &[Component]) -> String {
    let mut code = Vec::new();

    for comp in components {
        match comp.component_type {
            ComponentType::Label => {
                code.push(format!("  // Label: {}", comp.id));
                code.push(format!("  display.setCursor({}, {});", comp.x, comp.y));
                if let Some(size) = comp.properties.font_size {
                    code.push(format!("  display.setTextSize({});", size / 8));
                }
                if let Some(ref color) = comp.properties.color {
                    code.push(format!("  display.setTextColor({});", color));
                }
                if let Some(ref text) = comp.properties.text {
                    code.push(format!("  display.println(\"{}\");", text));
                }
            }
            ComponentType::Rectangle => {
                code.push(format!("  // Rectangle: {}", comp.id));
                if let Some(ref bg_color) = comp.properties.background_color {
                    code.push(format!("  display.fillRect({}, {}, {}, {}, {});",
                        comp.x, comp.y, comp.width, comp.height, bg_color));
                } else if let Some(ref border_color) = comp.properties.border_color {
                    code.push(format!("  display.drawRect({}, {}, {}, {}, {});",
                        comp.x, comp.y, comp.width, comp.height, border_color));
                }
            }
            ComponentType::Button => {
                code.push(format!("  // Button: {}", comp.id));
                if let Some(ref bg_color) = comp.properties.background_color {
                    code.push(format!("  display.fillRoundRect({}, {}, {}, {}, 5, {});",
                        comp.x, comp.y, comp.width, comp.height, bg_color));
                }
                if let Some(ref text) = comp.properties.text {
                    code.push(format!("  display.setCursor({}, {});",
                        comp.x + 10, comp.y + (comp.height / 2) as i32 - 4));
                    code.push(format!("  display.println(\"{}\");", text));
                }
            }
            ComponentType::Circle => {
                code.push(format!("  // Circle: {}", comp.id));
                let radius = comp.width.min(comp.height) / 2;
                let center_x = comp.x + radius as i32;
                let center_y = comp.y + radius as i32;
                if let Some(ref bg_color) = comp.properties.background_color {
                    code.push(format!("  display.fillCircle({}, {}, {}, {});",
                        center_x, center_y, radius, bg_color));
                } else if let Some(ref border_color) = comp.properties.border_color {
                    code.push(format!("  display.drawCircle({}, {}, {}, {});",
                        center_x, center_y, radius, border_color));
                }
            }
            _ => {}
        }
        code.push("".to_string());
    }

    code.join("\n")
}

fn generate_esphome_lambda(components: &[Component]) -> String {
    let mut code = Vec::new();

    for comp in components {
        match comp.component_type {
            ComponentType::Label => {
                if let Some(ref text) = comp.properties.text {
                    code.push(format!("      it.print({}, {}, id(font), \"{}\");",
                        comp.x, comp.y, text));
                }
            }
            ComponentType::Rectangle => {
                code.push(format!("      it.rectangle({}, {}, {}, {});",
                    comp.x, comp.y, comp.width, comp.height));
            }
            _ => {}
        }
    }

    code.join("\n")
}

// ============================================================================
// Main
// ============================================================================

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            save_project,
            load_project,
            generate_arduino_code,
            generate_esphome_code,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
